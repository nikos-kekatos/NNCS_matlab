function [net] = nn_training(data,options)
%nn_training This is for the NN training.
%   Detailed explanation goes here

outputArg1 = inputArg1;
outputArg2 = inputArg2;
% load('random_reference_multiple_simulations_40traces_robotic_arm_time_05-02-2020_16:00.mat')

if options.use_error_dyn
    if options.use_previous_y
        if options.use_previous_u
            in=[REF_array-Y_array [0;REF_array(1:end-1)-Y_array(1:end-1)] [0;0;REF_array(1:end-2)-Y_array(1:end-2)]...
                [0;0;0;REF_array(1:end-3)-Y_array(1:end-3)] [0;U_array(1:end-1)] [0;0;U_array(1:end-2)]...
                [0;0;0;U_array(1:end-3)]]';
        else
            in=[REF_array-Y_array [0;REF_array(1:end-1)-Y_array(1:end-1)] [0;0;REF_array(1:end-2)-Y_array(1:end-2)]...
                [0;0;0;REF_array(1:end-3)-Y_array(1:end-3)]]';
        end
    else
        in=[REF_array-Y_array]';
    end
else
    if options.use_previous_y
        if options.use_previous_ref
            if options.use_previous_u
                in=[[REF_array] [0;REF_array(1:end-1)] [0;0;REF_array(1:end-2)] [0;0;0;REF_array(1:end-3)]...
                    [Y_array] [0;Y_array(1:end-1)] [0;0;Y_array(1:end-2)] [0;0;0;Y_array(1:end-3)]...
                    [0;U_array(1:end-1)] [0;0;U_array(1:end-2)]...
                    ]';
            else
                in=[[REF_array] [0;REF_array(1:end-1)] [0;0;REF_array(1:end-2)] [0;0;0;REF_array(1:end-3)]...
                    [Y_array] [0;Y_array(1:end-1)] [0;0;Y_array(1:end-2)] [0;0;0;Y_array(1:end-3)]...
                    ]';
            end
        else
            if options.use_previous_u
                in=[REF_array Y_array [0;Y_array(1:end-1)] [0;0;Y_array(1:end-2)]...
                    [0;0;0;Y_array(1:end-3)] [0;U_array(1:end-1)] [0;0;U_array(1:end-2)]...
                    ]';
            else
                in=[[REF_array] ...
                    [Y_array] [0;Y_array(1:end-1)] [0;0;Y_array(1:end-2)] [0;0;0;Y_array(1:end-3)]...
                    ]';
            end
        end
    else
         if options.use_previous_u
                in=[REF_array Y_array...
                    [0;U_array(1:end-1)] [0;0;U_array(1:end-2)]...
                    ]';
            else
                in=[[REF_array] ...
                    [Y_array] ...
                    ]';
            end
    end
end

% Input normalization
        in=mapminmax(in);
        
        % net=feedforwardnet([64 64 ]); 
        net=feedforwardnet([20 20 ]);
        %net.numLayers=3;
        net = configure(net,in,out);
        activationFcn='tansig' % 'tansig' 'logisg' 'purelin' 'poslin'
        net.layers{1}.transferFcn=activationFcn;
        net.layers{2}.transferFcn=activationFcn;
      
        % net.trainParam.epochs = 100;
        % net.trainParam.goal = 1e-6;
        %   net.trainFcn='traingdx'
        %  net.trainFcn= 'trainscg'
        % net.performFcn='crossentropy'
        % net.divideFcn='divideint'
        net = init(net);
        [net,tr] = train(net, in, out)
        weights = getwb(net)
        weight=net.IW{1}
        weight1=net.LW{2}
        b1=net.b{1}
        b2=net.b{2}
        
        p = [in];
        uu = sim(net,p)
        
        perf = perform(net,in,out)
        
        
        in=[REF_array-Y_array [0;REF_array(1:end-1)-Y_array(1:end-1)] [0;0;REF_array(1:end-2)-Y_array(1:end-2)]...
            [0;0;0;REF_array(1:end-3)-Y_array(1:end-3)]]';
        % in=smoothdata(in);
        if preprocess
            [in,index]=preprocessing(in);
        end
        in=mapminmax(in);
        
        out=U_array';
        if preprocess
            out=out(index);
        end
        net=feedforwardnet([20  20 ]);
        
        % net=feedforwardnet([8 16 4]);
        %net.numLayers=3;
        net = configure(net,in,out);
        activationFcn='tansig' % 'tansig' 'logisg' 'purelin' 'poslin'
        net.layers{1}.transferFcn=activationFcn;
        net.layers{2}.transferFcn=activationFcn;
        % net.layers{3}.transferFcn=activationFcn;
        % net.layers{4}.transferFcn='poslin';
        % net.trainParam.epochs = 100;
        % net.trainParam.goal = 1e-6;
        %   net.trainFcn='traingdx'
        %  net.trainFcn= 'trainscg'
        % net.performFcn='crossentropy'
        % net.divideFcn='divideint'
        net = init(net);
        [net,tr] = train(net, in, out);
        weights = getwb(net);
        weight=net.IW{1};
        weight1=net.LW{2};
        b1=net.b{1};
        b2=net.b{2};
        
        p = [in];
        uu = sim(net,p);
        
        perf = perform(net,in,out)
        
        %% TRAINING with error dynamics & plant outputs & control values
        % load('random_reference_random_x0_multiple_simulations_153traces_robotic_arm_time_06-02-2020_11:25.mat')
        load('random_reference_random_x0_multiple_simulations_81traces_robotic_arm_time_05-02-2020_19:17.mat')
        % load('random_reference_multiple_simulations_40traces_robotic_arm_time_05-02-2020_16:00.mat')
        % load(logFileName)
        
        in=[REF_array-Y_array [0;REF_array(1:end-1)-Y_array(1:end-1)] [0;0;REF_array(1:end-2)-Y_array(1:end-2)]...
            [0;0;0;REF_array(1:end-3)-Y_array(1:end-3)] [0;U_array(1:end-1)] [0;0;U_array(1:end-2)]...
            [0;0;0;U_array(1:end-3)]]';
        % in=smoothdata(in);
        % [in,index]=preprocessing(in);
        in=mapminmax(in);
        
        out=U_array';
        % out(index)=[];
        net=feedforwardnet([64  ]);
        
        % net=feedforwardnet([20 20     ]);
        %net.numLayers=3;
        net = configure(net,in,out);
        activationFcn='tansig' % 'tansig' 'logisg' 'purelin' 'poslin'
        net.layers{1}.transferFcn=activationFcn;
        net.layers{2}.transferFcn=activationFcn;
        % net.layers{3}.transferFcn=activationFcn;
        % net.layers{4}.transferFcn='poslin';
        % net.trainParam.epochs = 100;
        % net.trainParam.goal = 1e-6;
        %   net.trainFcn='traingdx'
        %  net.trainFcn= 'trainscg'
        % net.performFcn='crossentropy'
        % net.divideFcn='divideint'
        net = init(net);
        [net,tr] = train(net, in, out)
        weights = getwb(net)
        weight=net.IW{1}
        weight1=net.LW{2}
        b1=net.b{1}
        b2=net.b{2}
        
        p = [in];
        uu = sim(net,p)
        
        perf = perform(net,in,out)
        
        %% TRAINING without error dynamics but with references & plant outputs & control values
        % load('random_reference_random_x0_multiple_simulations_153traces_robotic_arm_time_06-02-2020_11:25.mat')
        % load('random_reference_random_x0_multiple_simulations_81traces_robotic_arm_time_05-02-2020_19:17.mat')
        % load('random_reference_multiple_simulations_40traces_robotic_arm_time_05-02-2020_16:00.mat')
        %load(logFileName)
        load('random_reference_random_x0_multiple_simulations_289traces_robotic_arm_time_06-02-2020_22:46.mat')
        
        in=[[REF_array] [0;REF_array(1:end-1)] [0;REF_array(1);REF_array(1:end-2)]...
            [Y_array] [0;Y_array(1:end-1)] [0;Y_array(1);Y_array(1:end-2)]...
            [0;U_array(1:end-1)] [0;U_array(1);U_array(1:end-2)]...
            ]';
        if preprocess
            [in,index]=preprocessing(in);
        end
        in=mapminmax(in);
        
        out=U_array';
        if preprocess
            out(index)=[];
        end
        % net=feedforwardnet([64 64 ]);
        
        net=feedforwardnet([16 4      ]);
        %net.numLayers=3;
        net = configure(net,in,out);
        activationFcn='tansig' % 'tansig' 'logisg' 'purelin' 'poslin'
        net.layers{1}.transferFcn=activationFcn;
        net.layers{2}.transferFcn=activationFcn;
        % net.layers{3}.transferFcn=activationFcn;
        % net.layers{4}.transferFcn='poslin';
        % net.trainParam.epochs = 100;
        % net.trainParam.goal = 1e-6;
        %   net.trainFcn='traingdx'
        %  net.trainFcn= 'trainscg'
        % net.performFcn='crossentropy'
        % net.divideFcn='divideint'
        net = init(net);
        [net,tr] = train(net, in, out)
        weights = getwb(net)
        weight=net.IW{1}
        weight1=net.LW{2}
        b1=net.b{1}
        b2=net.b{2}
        
        p = [in];
        uu = sim(net,p)
        
        perf = perform(net,in,out)
        %% TRAINING without error dynamics without controls but with references & plant outputs
        % load('ranrdom_reference_random_x0_multiple_simulations_153traces_robotic_arm_time_06-02-2020_11:25.mat')
        % load('random_reference_random_x0_multiple_simulations_81traces_robotic_arm_time_05-02-2020_19:17.mat')
        % load('random_reference_multiple_simulations_40traces_robotic_arm_time_05-02-2020_16:00.mat')
        %load(logFileName)
        % load('random_reference_random_x0_multiple_simulations_289traces_robotic_arm_time_06-02-2020_22:46.mat')
        
        in=[[REF_array] [0;REF_array(1:end-1)] [0;REF_array(1);REF_array(1:end-2)]...
            [Y_array] [0;Y_array(1:end-1)] [0;Y_array(1);Y_array(1:end-2)]...
            ]';
        if preprocess
            [in,index]=preprocessing(in);
        end
        in=mapminmax(in);
        
        out=U_array';
        if preprocess
            % out(index)=[];
            out=out(index);
        end
        % net=feedforwardnet([16 4 ]);
        
        net=feedforwardnet([18       ]);
        %net.numLayers=3;
        net = configure(net,in,out);
        activationFcn='tansig' % 'tansig' 'logisg' 'purelin' 'poslin'
        net.layers{1}.transferFcn=activationFcn;
        net.layers{2}.transferFcn=activationFcn;
        % net.layers{3}.transferFcn=activationFcn;
        % net.layers{4}.transferFcn='poslin';
        % net.trainParam.epochs = 100;
        % net.trainParam.goal = 1e-6;
        %   net.trainFcn='traingdx'
        %  net.trainFcn= 'trainscg'
        % net.performFcn='crossentropy'
        % net.divideFcn='divideint'
        net = init(net);
        [net,tr] = train(net, in, out);
        weights = getwb(net);
        weight=net.IW{1};
        weight1=net.LW{2};
        b1=net.b{1};
        b2=net.b{2};
        
        p = [in];
        uu = sim(net,p);
        
        perf = perform(net,in,out)
        
        
        
        
        
    end
    
